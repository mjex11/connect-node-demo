"use strict";
// Copyright 2021-2023 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodeHttp2Client = exports.createNodeHttp1Client = void 0;
const http2 = require("http2");
const http = require("http");
const https = require("https");
const connect_1 = require("@bufbuild/connect");
const node_universal_header_js_1 = require("./node-universal-header.js");
const node_error_js_1 = require("./node-error.js");
const protocol_1 = require("@bufbuild/connect/protocol");
/**
 * Create an HTTP client using the Node.js `http` or `https` package.
 *
 * The HTTP client is a simple function conforming to the type UniversalClientFn.
 * It takes an UniversalClientRequest as an argument, and returns a promise for
 * an UniversalClientResponse.
 */
function createNodeHttp1Client(httpOptions) {
    return async function request(req) {
        const sentinel = createSentinel();
        return new Promise((resolve, reject) => {
            sentinel.catch((e) => {
                reject(e);
            });
            h1Request(sentinel, req.url, Object.assign(Object.assign({}, httpOptions), { headers: (0, node_universal_header_js_1.webHeaderToNodeHeaders)(req.header), method: req.method, signal: req.signal }), (request) => {
                (0, protocol_1.pipeTo)(req.body, sinkRequest(sentinel, request), {
                    propagateDownStreamError: true,
                }).catch(sentinel.reject);
                request.on("response", (response) => {
                    var _a;
                    response.on("error", sentinel.reject);
                    response.on("abort", () => sentinel.reject(new connect_1.ConnectError("node response aborted", connect_1.Code.Aborted)));
                    response.on("timeout", () => sentinel.reject(new connect_1.ConnectError("node response timed out", connect_1.Code.Aborted)));
                    const trailer = new Headers();
                    resolve({
                        status: (_a = response.statusCode) !== null && _a !== void 0 ? _a : 0,
                        header: (0, node_universal_header_js_1.nodeHeaderToWebHeader)(response.headers),
                        body: h1ResponseIterable(sentinel, response, trailer),
                        trailer,
                    });
                });
            });
        });
    };
}
exports.createNodeHttp1Client = createNodeHttp1Client;
/**
 * Create an HTTP client using the Node.js `http2` package.
 *
 * Note that the client is bound to the authority, and by default, it will close
 * the HTTP/2 session after the response is read to the end.
 *
 * The HTTP client is a simple function conforming to the type UniversalClientFn.
 * It takes an UniversalClientRequest as an argument, and returns a promise for
 * an UniversalClientResponse.
 */
function createNodeHttp2Client(authority, keepSessionOpen, http2SessionOptions) {
    const sessionHolder = {
        options: http2SessionOptions,
        authority: new URL(authority).origin,
        keepOpen: keepSessionOpen,
        lastSession: undefined,
    };
    return async function request(req) {
        const sentinel = createSentinel();
        return new Promise((resolve, reject) => {
            sentinel.catch((e) => {
                reject(e);
            });
            h2Request(sentinel, sessionHolder, req.url, req.method, (0, node_universal_header_js_1.webHeaderToNodeHeaders)(req.header), {
                signal: req.signal,
            }, (stream) => {
                void (0, protocol_1.pipeTo)(req.body, sinkRequest(sentinel, stream), {
                    propagateDownStreamError: true,
                }).catch(sentinel.reject);
                stream.on("response", (headers) => {
                    var _a;
                    const response = {
                        status: (_a = headers[":status"]) !== null && _a !== void 0 ? _a : 0,
                        header: (0, node_universal_header_js_1.nodeHeaderToWebHeader)(headers),
                        body: h2ResponseIterable(sentinel, stream),
                        trailer: h2ResponseTrailer(stream),
                    };
                    resolve(response);
                });
            });
        });
    };
}
exports.createNodeHttp2Client = createNodeHttp2Client;
function h1Request(sentinel, url, options, onRequest) {
    let request;
    if (new URL(url).protocol.startsWith("https")) {
        request = https.request(url, options);
    }
    else {
        request = http.request(url, options);
    }
    request.on("error", sentinel.reject);
    request.on("abort", () => sentinel.reject(new connect_1.ConnectError("node request aborted", connect_1.Code.Aborted)));
    request.on("socket", function onRequestSocket(socket) {
        function onSocketConnect() {
            socket.off("connect", onSocketConnect);
            onRequest(request);
        }
        // If readyState is open, then socket is already open due to keepAlive, so
        // the 'connect' event will never fire so call onRequest explicitly
        if (socket.readyState === "open") {
            onRequest(request);
        }
        else {
            socket.on("connect", onSocketConnect);
        }
    });
}
function sinkRequest(sentinel, request) {
    return function write(iterable) {
        const it = iterable[Symbol.asyncIterator]();
        return new Promise((resolve, reject) => {
            sentinel.catch(reject);
            writeNext();
            function writeNext() {
                if (sentinel.isRejected()) {
                    return;
                }
                it.next().then((r) => {
                    if (r.done === true) {
                        request.end(resolve);
                        return;
                    }
                    request.write(r.value, "binary", function (e) {
                        if (e) {
                            if (request.writableEnded &&
                                (0, node_error_js_1.unwrapNodeErrorChain)(e)
                                    .map(node_error_js_1.getNodeErrorProps)
                                    .some((p) => p.code == "ERR_STREAM_WRITE_AFTER_END") &&
                                it.throw !== undefined) {
                                // If the server responds and closes the connection before the client has written the entire response
                                // body, we get an ERR_STREAM_WRITE_AFTER_END error code from Node.js here.
                                // We do want to notify the iterable of the error condition, but we do not want to reject our sentinel,
                                // because that would also affect the reading side.
                                it.throw(new connect_1.ConnectError("stream closed", connect_1.Code.Aborted)).catch(() => {
                                    //
                                });
                                return;
                            }
                            sentinel.reject(e);
                        }
                        else {
                            writeNext();
                        }
                    });
                }, (e) => {
                    sentinel.reject(e);
                });
            }
        });
    };
}
function h1ResponseIterable(sentinel, response, trailer) {
    const inner = response[Symbol.asyncIterator]();
    return {
        [Symbol.asyncIterator]() {
            return {
                async next() {
                    const r = await sentinel.race(inner.next());
                    if (r.done === true) {
                        (0, node_universal_header_js_1.nodeHeaderToWebHeader)(response.trailers).forEach((value, key) => {
                            trailer.set(key, value);
                        });
                        sentinel.resolve();
                        await sentinel;
                    }
                    return r;
                },
                throw(e) {
                    sentinel.reject(e);
                    throw e;
                },
            };
        },
    };
}
function h2Request(sentinel, sessionHolder, url, method, headers, options, onStream) {
    const requestUrl = new URL(url);
    if (requestUrl.origin !== sessionHolder.authority) {
        const message = `cannot make a request to ${requestUrl.origin}: the http2 session is connected to ${sessionHolder.authority}`;
        sentinel.reject(new connect_1.ConnectError(message, connect_1.Code.Internal));
        return;
    }
    if (sessionHolder.keepOpen &&
        sessionHolder.lastSession !== undefined &&
        !sessionHolder.lastSession.closed &&
        !sessionHolder.lastSession.destroyed) {
        return h2ConnectedSession(sessionHolder.lastSession);
    }
    const connectingSession = http2.connect(sessionHolder.authority, sessionHolder.options, h2ConnectedSession);
    connectingSession.on("error", h2SessionConnectError);
    function h2SessionConnectError(e) {
        sentinel.reject(e);
    }
    function h2ConnectedSession(session) {
        sessionHolder.lastSession = session;
        session.off("error", sentinel.reject);
        session.off("error", h2SessionConnectError);
        session.on("error", sentinel.reject);
        sentinel
            .finally(() => {
            session.off("error", sentinel.reject);
            if (!sessionHolder.keepOpen) {
                session.close();
            }
        })
            .catch(() => {
            // We intentionally swallow sentinel rejection - errors must
            // propagate through the request or response iterables.
        });
        const stream = session.request(Object.assign(Object.assign({}, headers), { ":method": method, ":path": requestUrl.pathname }), options);
        stream.on("error", function h2StreamError(e) {
            if (stream.writableEnded &&
                (0, node_error_js_1.unwrapNodeErrorChain)(e)
                    .map(node_error_js_1.getNodeErrorProps)
                    .some((p) => p.code == "ERR_STREAM_WRITE_AFTER_END")) {
                return;
            }
            sentinel.reject(e);
        });
        stream.on("abort", function h2StreamAbort() {
            sentinel.reject(new connect_1.ConnectError("node request aborted", connect_1.Code.Aborted));
        });
        onStream(stream);
    }
}
function h2ResponseTrailer(response) {
    const trailer = new Headers();
    response.on("trailers", (args) => {
        (0, node_universal_header_js_1.nodeHeaderToWebHeader)(args).forEach((value, key) => {
            trailer.set(key, value);
        });
    });
    return trailer;
}
function h2ResponseIterable(sentinel, response) {
    const inner = response[Symbol.asyncIterator]();
    return {
        [Symbol.asyncIterator]() {
            return {
                async next() {
                    const r = await sentinel.race(inner.next());
                    if (r.done === true) {
                        sentinel.resolve();
                        await sentinel;
                    }
                    return r;
                },
                throw(e) {
                    sentinel.reject(e);
                    throw e;
                },
            };
        },
    };
}
function createSentinel() {
    let res;
    let rej;
    let resolved = false;
    let rejected = false;
    const p = new Promise((resolve, reject) => {
        res = resolve;
        rej = reject;
    });
    const c = {
        resolve() {
            if (!resolved && !rejected) {
                resolved = true;
                res === null || res === void 0 ? void 0 : res();
            }
        },
        isResolved() {
            return resolved;
        },
        reject(reason) {
            if (!resolved && !rejected) {
                rejected = true;
                rej === null || rej === void 0 ? void 0 : rej((0, node_error_js_1.connectErrorFromNodeReason)(reason));
            }
        },
        isRejected() {
            return rejected;
        },
        async race(promise) {
            const r = await Promise.race([promise, p]);
            if (r === undefined && resolved) {
                throw new connect_1.ConnectError("sentinel completed early", connect_1.Code.Internal);
            }
            return r;
        },
    };
    return Object.assign(p, c);
}
